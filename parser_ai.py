import os
import re
import json
import asyncio
from openai import AsyncOpenAI
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv("OPENAI_API_KEY")
client = AsyncOpenAI(api_key=api_key)

# ------------------ –ù–ê–°–¢–†–û–ô–ö–ò ------------------

LLM_MODEL = "gpt-4o-mini"   # —É—Å—Ç–æ–π—á–∏–≤–µ–µ –Ω–∞ –¥–ª–∏–Ω–Ω—ã—Ö —Å–ø–∏—Å–∫–∞—Ö
LLM_TIMEOUT = 30             # —Å–µ–∫ –Ω–∞ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å
LLM_MAX_CONCURRENCY = 5      # –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ LLM
LLM_MAX_RETRIES = 3          # —Ä–µ—Ç—Ä–∞–∏ –Ω–∞ —Å—Ç—Ä–æ–∫—É

# –¶–µ–Ω–∞: —Å—Ç—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç—ã "-20.000", "20.000", "-20,000", "20,000"
PRICE_RE = re.compile(
	r'(?P<price>-?\d{1,3}[.,]\d{3})(?!\d)',  # —á–∏—Å–ª–æ —Å 1‚Äì3 —Ü–∏—Ñ—Ä–∞–º–∏, –∑–∞—Ç–µ–º –∑–∞–ø—è—Ç–∞—è/—Ç–æ—á–∫–∞ –∏ –µ—â—ë 3 —Ü–∏—Ñ—Ä—ã
	re.IGNORECASE
)
EMOJI_RE = re.compile(r'[\U00010000-\U0010ffff]', flags=re.UNICODE)

# –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç: –û–î–ù–ê —Å—Ç—Ä–æ–∫–∞ ‚Üí –û–î–ò–ù –æ–±—ä–µ–∫—Ç
SINGLE_LINE_SYSTEM_PROMPT = """
–¢—ã ‚Äî –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ Telegram-–ø–æ—Å—Ç–∞ –æ –ø—Ä–æ–¥–∞–∂–µ —Ç–µ—Ö–Ω–∏–∫–∏ –∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∏.

–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –∏–∑–≤–ª–µ–∫–∞—Ç—å –¢–û–õ–¨–ö–û —Ä–µ–∞–ª—å–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç—Å—è –∫ –ø—Ä–æ–¥–∞–∂–µ –∏–ª–∏ —É–ø–æ–º–∏–Ω–∞—é—Ç—Å—è –∫–∞–∫ –ø–æ–∑–∏—Ü–∏–∏ —Å —Ü–µ–Ω–æ–π.
–ò–≥–Ω–æ—Ä–∏—Ä—É–π —Å–ø—Ä–∞–≤–æ—á–Ω—ã–µ, –æ–±—É—á–∞—é—â–∏–µ –∏–ª–∏ –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏, –æ–ø–∏—Å–∞–Ω–∏–µ –º–æ–¥–µ–ª–µ–π, —Å—Ç—Ä–∞–Ω, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π, —Ñ—É–Ω–∫—Ü–∏–π –∏ —Ç.–¥.).

–ù–∞ –≤—Ö–æ–¥ –ø–æ–¥–∞—é—Ç—Å—è —Å—Ç—Ä–æ–∫–∏ (–∏–ª–∏ –Ω–µ–±–æ–ª—å—à–∏–µ –±–ª–æ–∫–∏) —Ç–µ–∫—Å—Ç–∞. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –≤–µ—Ä–Ω—É—Ç—å —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω –æ–±—ä–µ–∫—Ç JSON –≤–∏–¥–∞:

{
  "–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞": "",
  "–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
  "–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
  "—Ü–≤–µ—Ç": "",
  "–º–æ–¥–µ–ª—å": "",
  "—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏": "",
  "—Ü–µ–Ω–∞": ""
}

---
üß≠ –õ–æ–≥–∏–∫–∞:

1. –°—Ç—Ä–æ–∫–∞ –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–æ–≤–∞—Ä, –µ—Å–ª–∏ –≤ –Ω–µ–π —É–∫–∞–∑–∞–Ω–∞ —Ü–µ–Ω–∞ –∏ –µ—Å—Ç—å —Å–ª–æ–≤–∞, –ø–æ—Ö–æ–∂–∏–µ –Ω–∞ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏, –±—Ä–µ–Ω–¥–∞ –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.

2. –ï—Å–ª–∏ –≤ —Å—Ç—Ä–æ–∫–µ –µ—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –±—Ä–µ–Ω–¥ (–Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –º–æ–¥–µ–ª—å—é ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä "Canon PowerShot", "GoPro HERO12", "Fujifilm Instax"), —Å—á–∏—Ç–∞–π —ç—Ç–æ **–±—Ä–µ–Ω–¥–æ–º** –∏ –∑–∞–ø–∏—à–∏ –µ–≥–æ –≤ –ø–æ–ª–µ `"–∫–∞—Ç–µ–≥–æ—Ä–∏—è"`.

3. –ï—Å–ª–∏ —è–≤–Ω–æ–≥–æ –±—Ä–µ–Ω–¥–∞ –Ω–µ—Ç, –Ω–æ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç —É–∑–Ω–∞–≤–∞–µ–º–∞—è –º–æ–¥–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, "A16", "HERO13", "Instax mini 12", "PowerShot"), –ø–æ–ø—Ä–æ–±—É–π –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –±—Ä–µ–Ω–¥ –ø–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–º —à–∞–±–ª–æ–Ω–∞–º –º–æ–¥–µ–ª–µ–π. –ï—Å–ª–∏ –º–æ–¥–µ–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–∏ —É –æ–¥–Ω–æ–≥–æ –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –±—Ä–µ–Ω–¥–æ–≤ ‚Äî –æ—Å—Ç–∞–≤—å `"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±—Ä–µ–Ω–¥"`.

4. –û–ø—Ä–µ–¥–µ–ª–∏ –ø–æ–ª–µ "–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è" ‚Äî —ç—Ç–æ —Ç–∏–ø –∏–ª–∏ —Å–µ—Ä–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞, –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–∞ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.

   - "–ö–∞—Ç–µ–≥–æ—Ä–∏—è" = –±—Ä–µ–Ω–¥ –∏–ª–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å (Apple, Canon, GoPro, Fujifilm, Sony, Samsung, Polaroid, Whoop, Ray Ban –∏ —Ç.–¥.)
   - "–ü–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è" = —Ç–∏–ø –∏–ª–∏ —Å–µ—Ä–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤, –µ—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –±—ã–≤–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ç–æ–≤–∞—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: —É Apple ‚Äî iPhone / iPad / MacBook).
   - "–ú–æ–¥–µ–ª—å" = –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏, –ø–æ–∫–æ–ª–µ–Ω–∏—è –∏–ª–∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: "14 Pro Max", "G7 X Mark III", "HERO12", "mini 12").

   üìò –ü—Ä–∏–º–µ—Ä—ã:
   - "Apple iPhone 14 Pro Max" ‚Üí –∫–∞—Ç–µ–≥–æ—Ä–∏—è: Apple, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: iPhone, –º–æ–¥–µ–ª—å: 14 Pro Max
   - "Apple MacBook Air M2" ‚Üí –∫–∞—Ç–µ–≥–æ—Ä–∏—è: Apple, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: MacBook, –º–æ–¥–µ–ª—å: Air M2
   - "Canon PowerShot G7 X Mark III" ‚Üí –∫–∞—Ç–µ–≥–æ—Ä–∏—è: Canon, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: PowerShot, –º–æ–¥–µ–ª—å: G7 X Mark III
   - "Whoop 5.0 Peak" ‚Üí –∫–∞—Ç–µ–≥–æ—Ä–∏—è: Whoop, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: –ë–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –º–æ–¥–µ–ª—å: 5.0 Peak
   - "Ray Ban Wayfarer RW4006" ‚Üí –∫–∞—Ç–µ–≥–æ—Ä–∏—è: Ray Ban, –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è: –ë–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –º–æ–¥–µ–ª—å: RW4006

   üß© –ü—Ä–∞–≤–∏–ª–∞:
   - –ï—Å–ª–∏ –±—Ä–µ–Ω–¥ –≤ —Ü–µ–ª–æ–º –≤—ã–ø—É—Å–∫–∞–µ—Ç –æ–¥–∏–Ω —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä Whoop –¥–µ–ª–∞–µ—Ç —Ç–æ–ª—å–∫–æ –±—Ä–∞—Å–ª–µ—Ç—ã, Ray Ban —Ç–æ–ª—å–∫–æ –æ—á–∫–∏), –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω—É–∂–Ω–∞ ‚Üí —É–∫–∞–∂–∏ "–ë–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏".
   - –ï—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π (Apple, Samsung, Canon –∏ —Ç.–ø.), –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω—É–∂–Ω–∞, —á—Ç–æ–±—ã —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∏—Ö.
   - –ï—Å–ª–∏ —Å–ª–æ–≤–æ –ø–æ—Å–ª–µ –±—Ä–µ–Ω–¥–∞ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å–µ—Ä–∏—é (HERO, PowerShot, Instax mini, iPhone), –∏—Å–ø–æ–ª—å–∑—É–π –µ–≥–æ –∫–∞–∫ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é.
   - –ù–∏–∫–æ–≥–¥–∞ –Ω–µ —Å—Ç–∞–≤—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –º–æ–¥–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä HERO12, G7 X Mark III) –≤ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é.
   - –ï—Å–ª–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø, –Ω–æ –≤–∏–¥–Ω–æ, —á—Ç–æ –±—Ä–µ–Ω–¥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –≤–∏–¥ —Ç–æ–≤–∞—Ä–æ–≤ ‚Äî –æ—Å—Ç–∞–≤—å "–ë–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏".

5. –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–æ–ª—å–∫–æ —Ü–≤–µ—Ç –∏ —Ü–µ–Ω–∞ –±–µ–∑ –±—Ä–µ–Ω–¥–∞), –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–Ω—Ç–µ–∫—Å—Ç: –ø–æ–¥—Å—Ç–∞–≤—å —Ç–æ—Ç –∂–µ –±—Ä–µ–Ω–¥ –∏ —Ç–∏–ø, —á—Ç–æ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–æ–∫–µ —Å –ø–æ–ª–Ω—ã–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º.

6. –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ. –ï—Å–ª–∏ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞ –µ—Å—Ç—å –±—Ä–µ–Ω–¥ ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–π –µ–≥–æ –≤ `"–∫–∞—Ç–µ–≥–æ—Ä–∏—è"`.

7. –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å:
   - –í—Å–µ —Ç–æ–≤–∞—Ä—ã –æ–¥–Ω–æ–≥–æ –±—Ä–µ–Ω–¥–∞ –≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ ‚Äî –ª–∏–±–æ —Å –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏, –ª–∏–±–æ –±–µ–∑ –Ω–∏—Ö.
   - –ï—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä —Å–º–∞—Ä—Ç—Ñ–æ–Ω—ã –∏ –Ω–æ—É—Ç–±—É–∫–∏) ‚Äî –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω—É–∂–Ω—ã.
   - –ï—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –≤—Å—ë –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ ‚Äî –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –Ω—É–∂–Ω—ã –≤–æ–æ–±—â–µ.

"""

# ------------------ –ü–û–ú–û–©–ù–ò–ö–ò ------------------

def _stitch_candidates(full_text: str) -> list[str]:
    """
    –°–æ–±–∏—Ä–∞–µ–º –ö–ê–ù–î–ò–î–ê–¢-–°–¢–†–û–ö–ò: —á–∏—Ç–∞–µ–º –í–°–Å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏,
    –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Ü–µ–Ω–∞. –ß—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å —Ç–æ–≤–∞—Ä—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö
    –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ —Ü–µ–Ω–∞ —Ä–∞–∑–Ω–µ—Å–µ–Ω—ã –ø–æ —Å–æ—Å–µ–¥–Ω–∏–º —Å—Ç—Ä–æ–∫–∞–º, –ø—ã—Ç–∞–µ–º—Å—è —Å–∫–ª–µ–∏—Ç—å 1-2
    –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä–æ–∫–∏, –µ—Å–ª–∏ –ø–µ—Ä–≤–∞—è –±–µ–∑ —Ü–µ–Ω—ã, –∞ —Å–ª–µ–¥—É—é—â–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç —Ü–µ–Ω—É.
    """
    raw_lines = [EMOJI_RE.sub("", l).strip() for l in full_text.splitlines()]
    raw_lines = [l for l in raw_lines if l]  # —É–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ

    candidates = []
    i = 0
    n = len(raw_lines)
    while i < n:
        line = raw_lines[i]
        if PRICE_RE.search(line):
            candidates.append(line)
            i += 1
            continue

        # –ü—ã—Ç–∞–µ–º—Å—è —Å–∫–ª–µ–∏—Ç—å —Å 1‚Äì2 —Å–ª–µ–¥—É—é—â–∏–º–∏ —Å—Ç—Ä–æ–∫–∞–º–∏, –µ—Å–ª–∏ —Ç–∞–º –ø–æ—è–≤–∏—Ç—Å—è —Ü–µ–Ω–∞
        made = False
        for span in (1, 2):
            if i + span < n:
                combo = " ".join(raw_lines[i:i+span+1])
                if PRICE_RE.search(combo):
                    candidates.append(combo)
                    i += span + 1
                    made = True
                    break
        if not made:
            i += 1

    return candidates

# --- —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω—ã ---
def normalize_price(s: str) -> str:
	nums = re.findall(r"\d+", s.replace(",", "").replace(".", "").replace(" ", ""))
	if not nums:
		return ""
	raw = "".join(nums)
	try:
		price = int(raw)
		return f"{price:,} ‚ÇΩ".replace(",", " ")
	except ValueError:
		return ""

# --- —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤ ---
def is_valid_item(item: dict) -> bool:
	name = item.get("–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞", "").strip()
	if not name or len(name) < 3:
		return False
	if any(x in name.lower() for x in ["–¥–æ—Å—Ç–∞–≤–∫–∞", "—Ä–∞—Å–ø—Ä–æ–¥–∞–∂–∞", "–∞–∫—Ü–∏—è", "–Ω–æ–≤–∏–Ω–∫–∏", "—Å–∫–∏–¥–∫–∞", "–≥–∞—Ä–∞–Ω—Ç–∏—è"]):
		return False
	if not item.get("—Ü–µ–Ω–∞"):
		return False
	return True

async def _parse_line_with_gpt(line: str, context_before: str = "", context_after: str = "") -> dict | None:
	"""
	–ü–∞—Ä—Å–∏–º –û–î–ù–£ —Å—Ç—Ä–æ–∫—É —á–µ—Ä–µ–∑ GPT —Å —É—á—ë—Ç–æ–º —Å–æ—Å–µ–¥–Ω–µ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.
	"""
	context_text = ""
	if context_before or context_after:
		context_text = (
			"–ö–æ–Ω—Ç–µ–∫—Å—Ç:\n"
			f"–î–æ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –±—ã–ª–æ:\n{context_before.strip()}\n\n"
			f"–ü–æ—Å–ª–µ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –∏–¥—ë—Ç:\n{context_after.strip()}\n\n"
			"–ï—Å–ª–∏ —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —á–∞—Å—Ç—å –æ–ø–∏—Å–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –µ–º–∫–æ—Å—Ç—å, —Ü–≤–µ—Ç–∞, —Ä–µ–≥–∏–æ–Ω—ã, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, "
			"–º–æ–¥–µ–ª–∏, –∫–æ–¥—ã –∏ —Ç.–ø.), –∏ –Ω–µ—Ç —è–≤–Ω–æ–π —Ü–µ–Ω—ã ‚Äî –ù–ï —Å—á–∏—Ç–∞–π —ç—Ç–æ —Ç–æ–≤–∞—Ä–æ–º.\n"
		)

	messages = [
		{"role": "system", "content": SINGLE_LINE_SYSTEM_PROMPT},
		{"role": "user", "content": context_text + f"–ê —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å—Ç—Ä–æ–∫—É:\n{line.strip()}"}
	]

	try:
		resp = await asyncio.wait_for(
			client.chat.completions.create(
				model=LLM_MODEL,
				messages=messages,
				response_format={"type": "json_object"},
			),
			timeout=LLM_TIMEOUT
		)
	except asyncio.TimeoutError:
		return None
	except Exception as e:
		print(f"‚ö†Ô∏è LLM error: {e}")
		return None

	reply = getattr(resp.choices[0].message, "content", None)
	if not reply or not reply.strip():
		return None

	try:
		data = json.loads(reply)
		if isinstance(data, list):
			data = data[0] if data else None
		if not isinstance(data, dict):
			return None
		return data
	except Exception:
		m = re.search(r"\{.*\}", reply, re.S)
		if not m:
			return None
		try:
			return json.loads(m.group(0))
		except Exception:
			return None

async def _safe_parse_line(lines: list[str], index: int, sem: asyncio.Semaphore) -> dict | None:
	"""
	–ü—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–æ–±—Ä–∞—Ç—å —Å—Ç—Ä–æ–∫—É —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
	"""
	line = lines[index]
	context_before = "\n".join(lines[max(0, index - 2): index])
	context_after = "\n".join(lines[index + 1: index + 3])

	for attempt in range(LLM_MAX_RETRIES):
		async with sem:
			parsed = await _parse_line_with_gpt(line, context_before, context_after)
		if parsed:
			return parsed
		await asyncio.sleep(0.3 * (attempt + 1))

	# fallback
	m = PRICE_RE.search(line)
	if not m:
		return None
	raw_price = m.group("price")
	price_norm = normalize_price(raw_price)
	name = re.sub(r'\s*[-‚Äì‚Äî:]\s*$', "", line[:m.start()].strip())
	if len(name) < 2:
		return None
	return {
		"–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞": name,
		"–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
		"–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
		"—Ü–≤–µ—Ç": "",
		"–º–æ–¥–µ–ª—å": "",
		"—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏": "",
		"—Ü–µ–Ω–∞": price_norm or raw_price,
	}

# ------------------ –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø ------------------

def has_price_like(text: str) -> bool:
	"""
	–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –≤ —Ç–µ–∫—Å—Ç–µ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Ü–µ–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:
	-20.000 / 20.000 / -20,000 / 20,000
	"""
	return bool(PRICE_RE.search(text))

async def _safe_parse_line(lines: list[str], index: int, sem: asyncio.Semaphore) -> dict | None:
	"""
	–ü—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–æ–±—Ä–∞—Ç—å —Å—Ç—Ä–æ–∫—É —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
	"""
	line = lines[index]
	context_before = "\n".join(lines[max(0, index - 2): index])
	context_after = "\n".join(lines[index + 1: index + 3])

	for attempt in range(LLM_MAX_RETRIES):
		async with sem:
			parsed = await _parse_line_with_gpt(line, context_before, context_after)
		if parsed:
			return parsed
		await asyncio.sleep(0.3 * (attempt + 1))

	# fallback ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞
	m = PRICE_RE.search(line)
	if not m:
		return None  # –±–µ–∑ —Ü–µ–Ω—ã –Ω–∏—á–µ–≥–æ –Ω–µ —Å–æ–∑–¥–∞—ë–º
	raw_price = m.group("price")
	price_norm = normalize_price(raw_price)
	name = re.sub(r'\s*[-‚Äì‚Äî:]\s*$', "", line[:m.start()].strip())
	if len(name) < 2:
		return None
	return {
		"–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞": name,
		"–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
		"–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è": "",
		"—Ü–≤–µ—Ç": "",
		"–º–æ–¥–µ–ª—å": "",
		"—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏": "",
		"—Ü–µ–Ω–∞": price_norm or raw_price,
	}

def normalize_brands_and_subcats(items: list[dict]) -> list[dict]:
	"""
	–û–±—ä–µ–¥–∏–Ω—è–µ—Ç –ø–æ—Ö–æ–∂–∏–µ –±—Ä–µ–Ω–¥—ã –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.
	"""
	from collections import defaultdict
	if not items:
		return items

	# 1. –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –±—Ä–µ–Ω–¥–æ–≤ –∏ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π
	brand_counts = defaultdict(int)
	for it in items:
		b = (it.get("–∫–∞—Ç–µ–≥–æ—Ä–∏—è") or "").strip().lower()
		if b:
			brand_counts[b] += 1

	# 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –±—Ä–µ–Ω–¥ (–Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç—ã–π)
	main_brand = max(brand_counts, key=brand_counts.get) if brand_counts else ""

	# 3. –ü–æ–¥—Ä–∞–≤–Ω–∏–≤–∞–µ–º –±—Ä–µ–Ω–¥—ã: –≤—Å–µ —Å—Ö–æ–∂–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø—Ä–∏–≤–æ–¥–∏–º –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É
	for it in items:
		brand = (it.get("–∫–∞—Ç–µ–≥–æ—Ä–∏—è") or "").strip()
		if not brand or brand.lower() != main_brand:
			it["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = main_brand.capitalize()

	# 4. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏
	subcats_by_brand = defaultdict(set)
	for it in items:
		sub = (it.get("–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è") or "").strip()
		if sub and sub.lower() not in {"", "–±–µ–∑ —Ç–∏–ø–∞", "–±–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏"}:
			subcats_by_brand[it["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"]].add(sub)

	# 5. –ï—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–Ω—ã—Ö —Å–µ—Ä–∏–π (Kindle, PaperWhite, Scribe) ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∏—Ö.
	#    –ï—Å–ª–∏ —Å–µ—Ä–∏—è –æ–¥–Ω–∞ ‚Äî —É–±–∏—Ä–∞–µ–º –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–æ–æ–±—â–µ.
	for it in items:
		brand = it["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"]
		subs = subcats_by_brand.get(brand, set())
		if len(subs) <= 1:
			it["–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = ""
		else:
			# –µ—Å–ª–∏ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è –ø—É—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–µ–º –≤—ã–≤–µ—Å—Ç–∏ –µ—ë –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è
			sub = (it.get("–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è") or "").strip()
			if not sub:
				name = (it.get("–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞") or "").lower()
				for s in subs:
					if s.lower() in name:
						it["–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = s
						break

	return items

async def parse_full_message(text: str) -> list[dict]:
	"""
	1) –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ —á—Ç–æ-—Ç–æ –ø–æ—Ö–æ–∂–µ–µ –Ω–∞ —Ü–µ–Ω—É.
	2) –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî —Å—Ä–∞–∑—É –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç (—á—Ç–æ–±—ã –Ω–µ –ø–∞—Ä—Å–∏—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é).
	3) –í—ã–¥–µ–ª—è–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏, –≥–¥–µ –µ—Å—Ç—å —Ü–µ–Ω—ã.
	4) –ü—Ä–æ–≥–æ–Ω—è–µ—Ç –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É —á–µ—Ä–µ–∑ GPT.
	5) –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç —Ç–æ–≤–∞—Ä—ã.
	"""
	# üîπ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –±–µ–∑ —Ü–µ–Ω–æ–ø–æ–¥–æ–±–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π
	if not has_price_like(text):
		print("‚è© –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ü–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—é –ø–æ–ª–Ω–æ—Å—Ç—å—é.")
		return []

	candidates = _stitch_candidates(text)
	print(f"üîé –ö–∞–Ω–¥–∏–¥–∞—Ç–æ–≤-—Å—Ç—Ä–æ–∫: {len(candidates)}")

	if not candidates:
		print("‚è© –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—Ç—Ä–æ–∫ —Å —Ü–µ–Ω–∞–º–∏ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—é —Å–æ–æ–±—â–µ–Ω–∏–µ.")
		return []

	sem = asyncio.Semaphore(LLM_MAX_CONCURRENCY)
	tasks = [asyncio.create_task(_safe_parse_line(candidates, i, sem)) for i in range(len(candidates))]
	parsed = await asyncio.gather(*tasks)

	results: list[dict] = []
	seen = set()  # –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–µ–π (name+price)

	for item in parsed:
		if not item:
			continue

		# –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ü–µ–Ω—É
		if item.get("—Ü–µ–Ω–∞"):
			item["—Ü–µ–Ω–∞"] = normalize_price(str(item["—Ü–µ–Ω–∞"])) or str(item["—Ü–µ–Ω–∞"])

		name = (item.get("–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞") or "").strip()
		price = (item.get("—Ü–µ–Ω–∞") or "").strip()
		if not name or not price:
			continue

		key = (name.lower(), price)
		if key in seen:
			continue
		seen.add(key)

		results.append({
			"–Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞": name,
			"–∫–∞—Ç–µ–≥–æ—Ä–∏—è": item.get("–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "").strip(),
			"–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è": item.get("–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "").strip(),
			"—Ü–≤–µ—Ç": item.get("—Ü–≤–µ—Ç", "").strip(),
			"–º–æ–¥–µ–ª—å": item.get("–º–æ–¥–µ–ª—å", "").strip(),
			"—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏": item.get("—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏", "").strip(),
			"—Ü–µ–Ω–∞": price,
		})
		
	results = simplify_subcategories(results)
	print(f"‚úÖ –ü–æ—Å–ª–µ —É–ø—Ä–æ—â–µ–Ω–∏—è –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π: {len(results)}")
	return results

def simplify_subcategories(results: list[dict]) -> list[dict]:
	"""
	–ï—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ç–∏–ø –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–∏–ª–∏ –≤—Å–µ '–ë–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏'),
	—Ç–æ —É–±–∏—Ä–∞–µ–º –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤–æ–æ–±—â–µ ‚Äî –æ–Ω–∞ –Ω–µ –Ω—É–∂–Ω–∞ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.
	"""
	from collections import defaultdict
	by_brand = defaultdict(list)
	for item in results:
		brand = item.get("–∫–∞—Ç–µ–≥–æ—Ä–∏—è") or ""
		if brand:
			by_brand[brand].append(item)

	for brand, items in by_brand.items():
		subcats = {it.get("–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "").lower() for it in items if it.get("–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è")}
		# –µ—Å–ª–∏ —É –±—Ä–µ–Ω–¥–∞ –æ–¥–Ω–∞ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è –∏–ª–∏ –≤—Å–µ –±–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî –æ—á–∏—â–∞–µ–º
		if len(subcats) <= 1 or subcats == {"–±–µ–∑ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–∏"}:
			for it in items:
				it["–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = ""

	results = normalize_brands_and_subcats(results)
	print(f"‚úÖ –ü–æ—Å–ª–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –±—Ä–µ–Ω–¥–æ–≤/–ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏–π: {len(results)}")
	return results
